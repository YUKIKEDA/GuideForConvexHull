# 第2章 2次元凸包の基礎理論

第1章で凸包の定義と応用を学びました。この章では、凸包アルゴリズムの**核となる幾何的な道具**と、凸包が満たす**重要な性質**を扱います。これらの理解なくして、正しく動作する凸包の実装はできません。

---

## 2.1 幾何的プリミティブ

### 3点の向き（左折・右折・同一直線上）

凸包アルゴリズムで最も頻繁に使う操作が、**3点 $O$, $A$, $B$ の向きの判定**です。

- 点 $O$ から $A$ へ進み、そのまま $B$ へ向かうとき、
  - **左折**するか
  - **右折**するか
  - **まっすぐ**（3点が同一直線上）か

を判定します。

```
        B
       /
      /  左折（反時計回り）
     A
    /
   O

   O ---- A ---- B    同一直線上

   O
    \
     A
      \  右折（時計回り）
       B
```

この判定は、Graham Scan で「スタックの top が左折を続けているか」を確認したり、QuickHull で「点が直線のどちら側にあるか」を調べたりする際に使います。

### 外積による向き判定の実装

**外積（符号付きのスカラー）** を使うと、3点の向きを効率的に判定できます。

点 $O = (o_x, o_y)$, $A = (a_x, a_y)$, $B = (b_x, b_y)$ に対して、ベクトル $\vec{OA} = A - O$ と $\vec{OB} = B - O$ の**外積**は

$$
\text{cross}(O, A, B) = (a_x - o_x)(b_y - o_y) - (a_y - o_y)(b_x - o_x)
$$

で定義します。2次元では外積はスカラー（符号付き）であり、その符号が向きを表します。

| 外積の符号 | 意味 |
|------------|------|
| $> 0$ | 左折（反時計回り） |
| $= 0$ | 同一直線上 |
| $< 0$ | 右折（時計回り） |

外積の絶対値は、ベクトル $\vec{OA}$ と $\vec{OB}$ が張る**平行四辺形の符号付き面積**の2倍になります。三角形 $OAB$ の面積の2倍とも一致するため、幾何的な意味付けができます。

**Python での実装例：**

```python
def cross(o: "Point2D", a: "Point2D", b: "Point2D") -> float:
    """3点 O, A, B の外積 (OA × OB) を返す。
    > 0: 左折, = 0: 同一直線上, < 0: 右折
    """
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)

def ccw(o: "Point2D", a: "Point2D", b: "Point2D") -> int:
    """反時計回り(CCW)なら 1, 同一直線上なら 0, 時計回り(CW)なら -1 を返す。"""
    c = cross(o, a, b)
    if c > 0:
        return 1   # 左折（反時計回り）
    if c < 0:
        return -1  # 右折（時計回り）
    return 0       # 同一直線上
```

**C++ の実装例：**

```cpp
double cross(const Point2D& o, const Point2D& a, const Point2D& b) {
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
}

int ccw(const Point2D& o, const Point2D& a, const Point2D& b) {
    double c = cross(o, a, b);
    if (c > 0) return 1;   // 反時計回り
    if (c < 0) return -1;  // 時計回り
    return 0;               // 同一直線上
}
```

### 数値的安定性と eps の扱い

浮動小数点演算には誤差が伴います。2つの実数が「等しい」かを `a == b` で判定すると、本来は等しいはずの値が誤差で異なると判定されることがあります。

**eps（イプシロン）による比較**

小さな閾値 $\varepsilon$（例：$10^{-9}$）を用意し、絶対値が $\varepsilon$ より小さければ「0とみなす」ようにします。

```python
EPS = 1e-9

def cross(o, a, b):
    c = (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)
    return c

def ccw(o, a, b):
    c = cross(o, a, b)
    if c > EPS:
        return 1
    if c < -EPS:
        return -1
    return 0
```

**eps の決め方**

- 座標のスケールに依存するため、入力の範囲に応じて調整する必要があります。
- 相対誤差を考慮する場合は、`eps = max(|a|, |b|) * 1e-9` のようにスケールする方法もあります。
- 競技プログラミングでは $10^{-9}$ 程度がよく使われますが、座標が非常に大きい場合や小さい場合は注意が必要です。
- 厳密さが求められる場合は、有理数演算や記号摂動（第9章）を検討します。

**eps の落とし穴**

- eps を大きくしすぎると、本来「同一直線上」でない3点を同一直線上と誤判定する可能性があります。
- eps を小さくしすぎると、浮動小数点の誤差で正しい判定ができなくなります。
- 実用上は、入力の桁数や問題の許容誤差に合わせて慎重に選びます。

---

## 2.2 凸包が満たす性質

凸包アルゴリズムの正しさを理解するため、凸包が満たす2つの重要な性質を押さえておきます。

### すべての点が凸包の「左側」にある

凸包を**反時計回り**に回る多角形として考えます。このとき、凸包の**任意の辺**について、凸包に含まれるすべての点（および凸包の他の辺）は、その辺の**左側**にあります。

言い換えれば、辺 $\overline{AB}$ に対して、凸包上の任意の点 $P$（$A$, $B$ を除く）は

$$
\text{cross}(A, B, P) \geq 0
$$

を満たします。等号は $P$ が辺 $\overline{AB}$ の延長上にある場合（退化ケース）に対応します。

この性質は、Graham Scan で「左折を続ける限りスタックに積む」「右折になったら pop する」という操作の根拠になっています。

### 時計回り/反時計回りの一貫性

凸包の頂点列は、**反時計回り（CCW）** または **時計回り（CW）** のいずれかで一貫して並べることができます。多くの実装では**反時計回り**が採用されます。

- 反時計回り：外積が常に正（左折のみ）
- 時計回り：外積が常に負（右折のみ）

Graham Scan では、基準点（通常は y 座標が最小の点）を選び、そこから極角でソートします。このとき、反時計回りに一周する順序で点を並べると、凸包を構築しやすくなります。

**一貫性の重要性**

アルゴリズム内で「左側」「右側」を判断するとき、凸包の回る向きが一貫していないと、条件が反転してバグの原因になります。実装時は、最初に「反時計回りで統一する」など方針を決めておくと安全です。

---

## 2.3 退化ケースの理解

アルゴリズムが正しく動作するためには、**退化ケース（degenerate case）** を適切に扱う必要があります。凸包では、以下のような状況が退化ケースに当たります。

### 同一直線上に並ぶ点

3点以上が同一直線上に並ぶ場合、外積が 0 になり、向きの判定が「同一直線上」としか言えません。

**影響**

- Graham Scan：極角が同じ点が複数あると、ソートの順序が不定になる可能性があります。このとき、凸包上で「より遠い点」を残し、近い点を捨てるようにすると正しく動作します。
- Gift Wrapping：同一直線上に複数の点がある場合、その中で「最も遠い点」を選ぶ必要があります。そうしないと、凸包の頂点を飛ばしてしまうことがあります。

**扱い方**

- 外積が 0 のときは「同一直線上」と判定し、必要に応じて**距離**で比較する（近い点より遠い点を優先する、など）。
- 凸包の出力に**共線点を含めるかどうか**は設計次第です。含める場合は、辺上に載る点も頂点として出力します。

### 重複点

同じ座標に複数の点が存在する場合です。

**影響**

- ソートや探索で重複をそのまま扱うと、同じ点を何度も処理して無駄が増えたり、無限ループに陥ったりする可能性があります。
- 凸包の頂点として重複した点を出力すると、見た目や後処理で混乱します。

**扱い方**

- 前処理で**重複を除去**するのが一般的です。座標でソートしたあと、隣接する同一点を削除します。
- 削除せずに扱う場合は、比較時に「座標が同じなら同一とみなす」ようにし、凸包の頂点列から重複を省く処理を入れます。

### 3点のみ、2点のみのケース

点の数が少ない場合の境界です。

| 点数 | 凸包の形 |
|------|----------|
| 0 | 空（エラー扱いまたは空集合として返す） |
| 1 | その1点のみ |
| 2 | 2点を結ぶ線分 |
| 3以上 | 凸多角形（3点の場合は三角形、共線なら線分） |

**影響**

- 3点が同一直線上に並んでいる場合は、凸包は**線分**（両端の2点）になります。
- 2点のみの場合、凸包は**線分**です。Graham Scan では基準点から極角ソートをしますが、2点しかないとソート結果が自明で、スタック操作も最小限で済みます。
- 1点以下の場合は、凸包アルゴリズムの前提（複数点がある）を満たさないため、事前にチェックして早期 return するのが安全です。

**実装時の指針**

```python
def convex_hull(points: List[Point2D]) -> List[Point2D]:
    if len(points) <= 1:
        return list(points)
    if len(points) == 2:
        return list(points)  # 線分が凸包
    # 以降、3点以上を仮定
    ...
```

---

## 本章のまとめ

- **3点の向き**は外積で判定できる。左折・右折・同一直線上を、正・負・ゼロで区別する。
- **外積の実装**は `(a.x - o.x)*(b.y - o.y) - (a.y - o.y)*(b.x - o.x)` で与えられる。
- **数値的安定性**のため、浮動小数点の比較では eps を使う。ただし eps の大きさは入力に応じて調整する。
- **凸包の性質**：任意の辺に対して、凸包のすべての点はその左側にある。頂点列は反時計回りまたは時計回りで一貫して並べられる。
- **退化ケース**：同一直線上の点、重複点、3点以下を適切に処理することが、ロバストな実装には不可欠である。

次の第3章から、具体的な凸包アルゴリズム（Gift Wrapping、Graham Scan など）を学んでいきます。この章で扱った外積と凸包の性質が、それらのアルゴリズムの土台になります。
