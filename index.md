# 凸包計算アルゴリズム 包括的学習教材

## 概要

Qhull などの凸包計算アルゴリズムを理論から実装まで完全習得するためのカリキュラム。初学者から上級者まで段階的に学べる構成。

---

## アウトライン

### Part I：基礎編（初学者向け）

#### 第1章 導入と準備
- 1.1 凸包とは何か
  - 直感的な定義（釘と輪ゴムの比喩）
  - 数学的定義（凸集合、凸包の厳密な定義）
  - 凸包の性質と特徴
- 1.2 なぜ凸包を学ぶのか
  - 応用例：衝突検出、パターン認識、地理情報システム、ロボティクス
- 1.3 前提知識の確認
  - 座標幾何の基礎（2D/3D）
  - ベクトルの内積・外積（ cross product ）
  - 三角関数の基礎
  - 計算量の考え方（O記法、 log n の意味）
- 1.4 開発環境のセットアップと可視化
  - 言語選定（Python / C++ など）
  - 可視化ツールの準備（matplotlib / OpenGL）
  - 可視化のベストプラクティス
    - ステップごとの凸包構築アニメーション
    - QuickHull の再帰分割の可視化
    - 3D 凸包の回転表示
    - エッジの visible / invisible 判定の可視化
- 1.5 基本的なデータ構造
  - 点の表現方法（構造体/クラス設計）
  - 辺・面の表現（half-edge 構造の予告）
  - 配列 vs リンクリスト vs スタック

#### 第2章 2次元凸包の基礎理論
- 2.1 幾何的プリミティブ
  - 3点の向き（左折・右折・同一直線上）
  - 外積による向き判定の実装
  - 数値的安定性と eps の扱い
- 2.2 凸包が満たす性質
  - すべての点が凸包の「左側」にある
  - 時計回り/反時計回りの一貫性
- 2.3 退化ケースの理解
  - 同一直線上に並ぶ点
  - 重複点
  - 3点のみ、2点のみのケース

---

### Part II：2次元凸包アルゴリズム（初級〜中級）

#### 第3章 Gift Wrapping（Jarvis March）
- 3.1 アルゴリズムのアイデア
  - 「最も左の点から始めて、ひたすら外側を巻いていく」
- 3.2 疑似コードと動作原理
- 3.3 計算量解析：O(nh)（h = 凸包の頂点数）
- 3.4 実装と演習
- 3.5 利点・欠点の整理
- 3.6 正しさの証明（Gift Wrapping が必ず外側を回る理由）

#### 第4章 Graham Scan
- 4.1 アルゴリズムのアイデア
  - 極角ソート + スタックによる走査
- 4.2 極角ソートの実装
  - 基準点の選び方（y最小、x最小など）
  - atan2 によるソートとその注意点
- 4.3 スタックによる凸包構築
- 4.4 計算量解析：O(n log n)
- 4.5 完全実装とデバッグ
- 4.6 退化ケースへの対応
- 4.7 正しさの証明（極角ソートが正しい理由）

#### 第5章 Andrew's Monotone Chain
- 5.1 Graham Scan の改良としての位置づけ
- 5.2 上下凸包に分けるアイデア
- 5.3 座標比較のみでソート（atan2 不要）
- 5.4 実装の簡潔さと数値安定性
- 5.5 Graham Scan との比較

#### 第6章 動的凸包
- 6.1 点の追加・削除に対応する凸包の更新
- 6.2 オンラインアルゴリズムの基礎
- 6.3 応用：リアルタイム処理

#### 第7章 QuickHull（分割統治法）
- 7.1 分割統治のアイデア
  - 最遠点で分割し、再帰的に凸包を構築
- 7.2 点と直線の距離・符号付き距離
- 7.3 疑似コードと再帰構造
- 7.4 平均計算量と最悪計算量
- 7.5 実装演習
- 7.6 正しさの証明（QuickHull の分割統治が全点を網羅する理由）

---

### Part III：応用と最適化（中級〜上級）

#### 第8章 Chan's Algorithm（最適アルゴリズム）
- 8.1 O(n log h) の意義
  - h が小さいときの効率化
- 8.2 アイデア：Graham Scan と Gift Wrapping の組み合わせ
- 8.3 パラメータ m の選び方
- 8.4 完全なアルゴリズムの導出
- 8.5 実装と検証
- 8.6 正しさの証明（Chan's Algorithm の O(n log h) の証明スケッチ）

#### 第9章 数値的ロバストネスと性能
- 9.1 浮動小数点の落とし穴
  - 比較の誤差、eps の決め方
- 9.2 幾何計算における一般的な落とし穴（Geometric Pitfalls）
  - 浮動小数点の丸め誤差による「向き判定の反転」
  - ほぼ共線点の扱い
  - 座標が巨大な場合のオーバーフロー
  - 整数座標 vs 浮動小数点座標の違い
- 9.3 有理数・任意精度演算
- 9.4 記号摂動（symbolic perturbation）
- 9.5 実用上のベストプラクティス
- 9.6 性能計測とプロファイリング
  - ベンチマーク設計
  - ボトルネック分析
  - キャッシュ効率の考慮

#### 第10章 退化ケースとエッジケースの網羅
- 10.1 全点が同一直線上
- 10.2 重複点の処理
- 10.3 3点以下の入力
- 10.4 共線点を許容するか削除するかの設計判断
- 10.5 テスト駆動開発と単体テスト
  - 単体テストの設計
  - テストデータ生成技法
    - ランダム点生成（均一分布、正規分布、円周上など）
    - 最悪ケース生成（全点が凸包上）
    - 退化ケース生成（共線点、重複点）
    - 大規模データ生成（100万点）
  - 既知の正解データとの比較
  - リグレッションテスト

#### 第11章 アルゴリズム選択ガイド
- 11.1 入力サイズと実データの特性に応じた選択
  - 点数が少ない場合
  - h が小さい場合（Chan's が有利）
  - 点が格子状に並ぶ場合
  - ノイズが多い場合
- 11.2 ストリーミングデータの場合（動的凸包）

---

### Part IV：3次元凸包（中級〜上級）

#### 第12章 3次元への拡張
- 12.1 3D 幾何の基礎
  - 平面の方程式、法線ベクトル
  - 4点の向き（四面体の符号付き体積）
- 12.2 3次元凸包の定義と性質
- 12.3 面・辺・頂点の関係（オイラー標数）

#### 第13章 3次元 Gift Wrapping
- 13.1 アイデアの 2D からの拡張
- 13.2 稜線ベースのアルゴリズム
- 13.3 計算量：O(nh)
- 13.4 実装

#### 第14章 3次元 QuickHull と増分構築法
- 14.1 3D QuickHull の概要
- 14.2 増分アルゴリズム（Incremental）
  - 点を1つずつ追加し、見える面を削除
- 14.3 衝突グラフと効率的な面削除
- 14.4 Qhull で使われているアイデアの前振り

#### 第15章 データ構造の詳細
- 15.1 Half-edge データ構造
- 15.2 DCEL（Doubly Connected Edge List）
- 15.3 面の隣接情報の管理

#### 第16章 3D 凸包の難しさと実装の罠
- 16.1 面の可視性判定の不安定性
- 16.2 Half-edge / DCEL の破損しやすさ
- 16.3 退化ケース（4点が同一平面上）
- 16.4 法線ベクトルの向きの一貫性

---

### Part V：Qhull と高度な話題（上級者向け）

#### 第17章 Qhull の内部構造
- 17.1 Qhull とは
  - 概要、歴史、利用分野
- 17.2 Qhull がサポートする構造
  - 凸包、Voronoi 図、Delaunay 三角分割
- 17.3 コアアルゴリズムの概要
  - QuickHull ベースの設計
- 17.4 入力・出力フォーマット
- 17.5 Qhull のソースコード読解のガイド
- 17.6 Qhull の高度な機能
  - オプションフラグの詳細（QJ, Qt など）
  - メモリ管理戦略
  - 並列化の可能性
- 17.7 Qhull のアルゴリズム的特徴の深掘り
  - facet merging 戦略
  - visible set の高速探索
  - randomized incremental algorithm の要素
  - 数値ロバストネスのための工夫（QJ, Qt の背景）

#### 第18章 高次元凸包
- 18.1 4次元以上への一般化
- 18.2 ファセット（超平面）の扱い
- 18.3 双対性（点と超平面の双対）
- 18.4 計算量と実用上の制約

#### 第19章 関連する幾何構造
- 19.1 Delaunay 三角分割
  - 定義、凸包との関係
- 19.2 Voronoi 図
  - 定義、Delaunay との双対性
- 19.3 凸包 ↔ Delaunay ↔ Voronoi の関係図
- 19.4 応用：メッシュ生成、補間

#### 第20章 スクラッチ実装プロジェクト
- 20.1 2D 凸包ライブラリの設計
  - API 設計、データ構造
- 20.2 3D 凸包の完全実装
- 20.3 ベンチマークと Qhull との比較
- 20.4 可視化ツールの自作
- 20.5 最適化技法
  - SIMD 命令の活用
  - マルチスレッド化
  - GPU 活用（参考程度）
- 20.6 ドキュメントとテストの整備

---

### Part VI：付録

#### 付録A 数学的補足
- 凸集合の性質
- 極点（extreme point）の厳密な定義
- 分離超平面定理（参考）

#### 付録B アルゴリズム一覧表
- アルゴリズム / 次元 / 計算量 / 特徴の比較表

#### 付録C 参考実装コード
- 各アルゴリズムの最小実装へのリンク

#### 付録D 参考文献・リソース
- 定番教科書（Computational Geometry 等）
- Qhull 公式ドキュメント
- オンラインリソース

---

## 想定学習時間の目安

| Part | 想定時間 | レベル |
|------|----------|--------|
| Part I | 2〜3日 | 初学者 |
| Part II | 1〜2週間 | 初級〜中級 |
| Part III | 1週間 | 中級〜上級 |
| Part IV | 1〜2週間 | 中級〜上級 |
| Part V | 2〜3週間 | 上級者 |
| Part VI | 随時参照 | - |

---

## カリキュラムの使い方

1. **順番に進める**：前の章の理解が次の章の前提になります
2. **手を動かす**：各アルゴリズムは必ず自分で実装してください
3. **可視化する**：2D は matplotlib、3D は適宜ツールを使って確認
4. **退化ケースを試す**：境界条件でバグを炙り出してください
5. **Qhull と比較する**：自作実装と Qhull の結果を突き合わせて検証

---

*このアウトラインは随時更新・拡張予定です。*
