# 第11章 アルゴリズム選択ガイド

ここまでに学んだ凸包アルゴリズムには、それぞれ得意な状況があります。この章では、**入力のサイズやデータの性質**に応じて、どのアルゴリズムを選ぶべきかを整理します。実務では、この判断が重要になります。

---

## 11.1 入力サイズと実データの特性に応じた選択

### アルゴリズム一覧の復習

| アルゴリズム | 計算量 | 特徴 | 章 |
|--------------|--------|------|-----|
| Gift Wrapping | $O(nh)$ | 実装が単純、最悪 $O(n^2)$ | 第3章 |
| Graham Scan | $O(n \log n)$ | 安定、atan2 が必要 | 第4章 |
| Andrew's Monotone Chain | $O(n \log n)$ | 数値的に安定、推奨 | 第5章 |
| QuickHull | 平均 $O(n \log n)$、最悪 $O(n^2)$ | 3次元への拡張が容易 | 第7章 |
| Chan's Algorithm | $O(n \log h)$ | $h$ が小さいとき最速、実装は複雑 | 第8章 |

---

### 点数が少ない場合（n が小さい）

**目安**：$n \leq 1000$ 程度

**推奨**：**Andrew's Monotone Chain** または **Graham Scan**

- 計算量の差は小さく、実装の簡単さと数値安定性が重要
- Andrew's Monotone Chain は atan2 を避けられるため、数値誤差に強い
- プロトタイプや競技プログラミングでは、Andrew's Monotone Chain をデフォルトにするのが無難

**避けた方がよい**：Chan's Algorithm（オーバーヘッドが効いてしまうことがある）

---

### h が小さい場合（Chan's が有利）

**目安**：凸包の頂点数 $h$ が $n$ に比べて十分小さい（例：$h < \sqrt{n}$）

**推奨**：**Chan's Algorithm**

- $O(n \log h)$ は $h \ll n$ のとき $O(n \log n)$ より高速
- 矩形内に一様分布した点では、$h$ は $O(\log n)$ 程度になることが知られている
- 点が密集している（クラスタ状）データで効果的

**例**：

- センサーが狭い領域に集中している
- クラスタの外形を求めたい
- 点が正規分布などで中央に集中している

**注意**：Chan の実装はやや複雑。$h$ の見積もりが難しい場合は、Andrew's Monotone Chain でも十分なことが多い。

---

### 点が格子状に並ぶ場合

**現象**：点が格子の交点に乗っている（例：$(\frac{i}{k}, \frac{j}{k})$）

**特徴**：

- 共線点が多く、退化ケースになりやすい
- 凸包の頂点数 $h$ は比較的少ない（矩形の周上程度）

**推奨**：

1. **Andrew's Monotone Chain**：座標比較のみでソートするため、共線点に強い
2. **前処理で重複除去**：格子点は重複しやすいため、重複除去を忘れない
3. **整数演算**：座標が整数なら、外積を整数で計算し、数値誤差を避ける

**注意**：atan2 を使う Graham Scan は、格子点で極角が一致しやすく、ソートが不安定になりやすい。

---

### ノイズが多い場合

**現象**：本来の形状にノイズ（外れ値）が混ざっている

**特徴**：

- 外れ値が凸包の頂点になり、$h$ が大きくなりがち
- 凸包が細かくギザギザになる

**推奨**：

1. **Andrew's Monotone Chain または Graham Scan**：$O(n \log n)$ で安定
2. **必要なら前処理**：外れ値除去やスムージングを行ってから凸包を計算する
3. **α-shape など**：凸包以外の形状（穴を許すなど）が適している場合は、別の手法を検討する

**避けた方がよい**：Gift Wrapping（$h$ が大きいと $O(nh)$ が重い）

---

### アルゴリズム選択のフローチャート

```
入力の性質は？
│
├─ 点が1つずつ順に追加される（ストリーミング）
│   → 第11.2節：動的凸包
│
├─ n が小さい（〜1000）
│   → Andrew's Monotone Chain
│
├─ h が小さいと予想される（密集した点）
│   → Chan's Algorithm（実装できる場合）
│   → そうでなければ Andrew's Monotone Chain
│
├─ 点が格子状
│   → Andrew's Monotone Chain + 重複除去 + 整数演算
│
├─ ノイズが多い
│   → Andrew's Monotone Chain（前処理を検討）
│
└─ 3次元以上が必要
    → QuickHull ベース（第12章以降）
```

---

## 11.2 ストリーミングデータの場合（動的凸包）

### 問題の特徴

点が**1つずつ順番に**到着し、そのたびに凸包を更新する必要がある場合、オフラインの凸包アルゴリズムを毎回実行するのは非効率です。

**例**：

- センサーデータのリアルタイム処理
- トラッキング中の点群の凸包
- インタラクティブな可視化（ユーザーが点を追加）

### 選択肢

| 方式 | 1回の追加 | 実装 | 推奨場面 |
|------|-----------|------|----------|
| **毎回再計算** | $O(n \log n)$ | 簡単 | $n$ が数千以下、実装優先 |
| **増分更新** | $O(\log n)$ | やや複雑 | $n$ が大きく、追加が頻繁 |

### 推奨

- **$n$ が数千以下**：Andrew's Monotone Chain を毎回実行する**素朴な動的凸包**で十分なことが多い（第6章参照）
- **$n$ が大きく、追加が非常に頻繁**：平衡二分探索木を用いた増分更新を検討する
- **削除も必要**：削除のたびに再計算するか、専用のデータ構造（Overmars–van Leeuwen 等）を検討する

### 実装の指針

```python
# 素朴な動的凸包（第6章）
class DynamicConvexHull:
    def __init__(self):
        self.points = []

    def add(self, p):
        self.points.append(p)

    def get_hull(self):
        return andrew_monotone_chain(self.points)
```

点の数が増えすぎる場合は、**サンプリング**や**スライディングウィンドウ**で古い点を捨てるなど、アプリケーションに合わせた設計が求められます。

---

## 本章のまとめ

- **点数が少ない**：Andrew's Monotone Chain をデフォルトにする
- **$h$ が小さい**：Chan's Algorithm が有利（実装できる場合）
- **格子状の点**：Andrew's Monotone Chain + 重複除去 + 整数演算
- **ノイズが多い**：Andrew's Monotone Chain、必要なら前処理
- **ストリーミング**：$n$ が小さければ毎回再計算、大きければ増分更新を検討する

次章からは **Part IV：3次元凸包** に入り、2次元の考え方を3次元に拡張します。
