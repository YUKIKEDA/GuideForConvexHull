# 第4章 Graham Scan

Graham Scan（グラハムスキャン）は、凸包を $O(n \log n)$ で求める古典的かつ実用的なアルゴリズムです。1972年に Ronald Graham によって発表されました。**極角ソート**と**スタック**を組み合わせて凸包を構築するのが特徴で、Gift Wrapping の最悪 $O(n^2)$ を改善します。

---

## 4.1 アルゴリズムのアイデア

### 極角ソート + スタックによる走査

Graham Scan の流れは次の2段階です。

1. **基準点を選び、極角でソート**  
   凸包の頂点であることが保証される点（通常は **y 座標が最小**の点）を基準点として選び、基準点から見た**極角（角度）** で全点をソートします。これにより、基準点の周りを反時計回りに一周する順序で点が並びます。

2. **スタックで凸包を構築**  
   ソートされた順に点を1つずつ処理します。新しい点を追加するとき、スタックの先頭2点とこの点が**右折**するなら、凸包の外側に出ているためスタックから pop します。左折するまで pop を繰り返してから、新しい点を push します。

```
基準点 O から見た極角でソート
       p3
      /
  p2 •     • p4
    |    /
    |   /
  p1 • /
    \/
    O (基準点)    →  O, p1, p2, p3, p4, ... の順で処理

スタックの動き:
  push O, push p1, push p2
  push p3 の前、p1-p2-p3 が右折 → pop p2
  p0-p1-p3 が左折 → push p3
  ...
```

この「右折したら pop、左折するまで待つ」という操作により、スタック上には常に凸包の頂点候補（左折のみで繋がった点列）が保たれます。

---

## 4.2 極角ソートの実装

### 基準点の選び方（y 最小、x 最小など）

基準点は**凸包の頂点であることが確実な点**である必要があります。代表的な選び方です。

| 選び方 | 基準 | 利点 |
|--------|------|------|
| **y 最小、同点なら x 最小** | 最も下（同じなら最も左）の点 | 凸包の下端にあり、極角が $-\pi$ から $\pi$ まで一意に定まる |
| **x 最小、同点なら y 最小** | 最も左の点 | Gift Wrapping と同じ発想で、実装の一貫性が取りやすい |
| **y 最大** | 最も上の点 | 座標系の向きによっては便利 |

多くの実装では **y 座標が最小**（同点なら x 座標が最小）を基準点にします。この点は凸包の下端にあり、基準点から見て全点が上半平面（y ≥ 基準点の y）に載るか、少なくとも極角が明確に定義できます。

### atan2 によるソートとその注意点

**atan2(y, x)** は、原点から点 (x, y) へのベクトルが x 軸の正の向きとなす角を $[-\pi, \pi]$ の範囲で返します。基準点を原点に平行移動した上で、各点の atan2 の値を比較すれば極角ソートができます。

```python
import math

def polar_angle(base, p):
    """基準点 base から見た点 p の極角（ラジアン）"""
    return math.atan2(p.y - base.y, p.x - base.x)

# ソート例
points_sorted = sorted(points, key=lambda p: polar_angle(base, p))
```

**注意点**

1. **同一直線上の点**  
   極角が同じ点が複数ある場合、ソートの順序が不定になります。このとき、**基準点に近い点を先に、遠い点を後に**並べる必要があります。そうしないと、凸包上で「近い点」が「遠い点」の後に来てしまい、スタック操作で誤った pop が起きることがあります。

2. **基準点の除外**  
   基準点自身は極角が定義されにくい（または不定）なので、ソート対象から除き、凸包の先頭に明示的に含めます。

3. **数値誤差**  
   atan2 は浮動小数点演算を使うため、ほぼ同一直線上にある点で極角が微妙にずれ、ソート順が不安定になることがあります。第5章の Andrew's Monotone Chain では atan2 を使わず、座標比較だけでソートする方法を扱います。

**同一直線上の扱い（距離で tie-break）**

```python
def compare_for_sort(base, p, q):
    """基準点 base から見て、p を q より前に並べるべきなら負を返す"""
    angle_p = math.atan2(p.y - base.y, p.x - base.x)
    angle_q = math.atan2(q.y - base.y, q.x - base.x)
    if abs(angle_p - angle_q) < 1e-9:
        # 同一直線上: 近い点を先に
        dist_p = (p.x - base.x)**2 + (p.y - base.y)**2
        dist_q = (q.x - base.x)**2 + (q.y - base.y)**2
        return dist_p - dist_q
    return angle_p - angle_q
```

---

## 4.3 スタックによる凸包構築

ソート後の点列を先頭から順に処理し、スタックで凸包を構築します。

### 操作のルール

現在のスタックを $[..., s_{k-1}, s_k]$ とし、次に処理する点を $p$ とします。

- **ccw($s_{k-1}$, $s_k$, $p$) > 0**（左折）  
  $p$ は凸包の外側に正しく進んでいる。$p$ を push する。

- **ccw($s_{k-1}$, $s_k$, $p$) < 0**（右折）  
  $s_k$ は凸包の頂点ではない。$s_k$ を pop し、再度 $p$ について判定する（スタックが2点以上ある限り繰り返す）。

- **ccw($s_{k-1}$, $s_k$, $p$) == 0**（同一直線上）  
  設計に依存する。凸包の辺上の中間点を含めたくない場合は、より遠い点を残すように pop するか、あるいは $p$ を push しないでスキップする実装もある。多くの実装では、同一直線上では**より遠い点を残す**ようにします。

### 疑似コード

```
GrahamScan(P):
    if |P| < 3:
        return P

    base = P のうち y が最小（同点なら x が最小）の点
    P' = P \ {base} を、base から見た極角でソート（同角なら距離が近い順）

    stack = [base]
    for each p in P':
        while len(stack) >= 2 and ccw(stack[-2], stack[-1], p) <= 0:
            stack.pop()
        stack.push(p)

    return stack
```

`ccw <= 0` にすることで、同一直線上の点については「より遠い点を残す」ポリシーを、ソートと組み合わせて実現できます。同一直線上では近い点が先に来るようにソートし、遠い点が来たときに近い点を pop する、という動きになります。

---

## 4.4 計算量解析：O(n log n)

- **基準点の選択**：$O(n)$
- **極角ソート**：$O(n \log n)$
- **スタックによる走査**：各点は高々1回 push、高々1回 pop されるため、合計 $O(n)$

したがって、全体の計算量は **$O(n \log n)$** です。Gift Wrapping の $O(nh)$ と異なり、凸包の頂点数 $h$ に依存しません。

---

## 4.5 完全実装とデバッグ

### Python 実装

```python
import math
from typing import List

class Point2D:
    def __init__(self, x: float, y: float):
        self.x, self.y = x, y

def cross(o, a, b) -> float:
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)

def ccw(o, a, b) -> int:
    c = cross(o, a, b)
    if c > 0: return 1
    if c < 0: return -1
    return 0

def dist_sq(a, b) -> float:
    return (b.x - a.x)**2 + (b.y - a.y)**2

def graham_scan(points: List[Point2D]) -> List[Point2D]:
    n = len(points)
    if n < 3:
        return list(points)

    # 基準点：y 最小、同点なら x 最小
    base = min(points, key=lambda p: (p.y, p.x))
    others = [p for p in points if p is not base]

    # 極角ソート（同角なら距離が近い順）
    def cmp_key(p):
        angle = math.atan2(p.y - base.y, p.x - base.x)
        return (angle, dist_sq(base, p))

    others.sort(key=cmp_key)

    stack = [base]
    for p in others:
        while len(stack) >= 2 and ccw(stack[-2], stack[-1], p) <= 0:
            stack.pop()
        stack.append(p)

    return stack
```

### デバッグのヒント

1. **共線点**：全点が同一直線上になると、凸包は線分になる。スタックの動作を確認する。
2. **基準点の重複**：`others` から基準点を除外する際、同じ座標の別の点が残っていないか確認する。重複点は前処理で除いておくと安全。
3. **ソート順**：同一直線上で「近い順」になっているか確認する。逆だと凸包が不正になることがある。
4. **可視化**：ソート後の点列と、スタックの変化を1ステップずつ描画すると、挙動が追いやすい。

---

## 4.6 退化ケースへの対応

| ケース | 対応 |
|--------|------|
| **0, 1, 2 点** | そのまま返す |
| **全点が同一直線上** | 両端の2点が凸包。極角がすべて同じなので、距離でソートすれば両端が先頭と末尾に来る。スタックでは右折判定で中間点が pop され、両端のみが残る。 |
| **重複点** | 事前に重複除去するか、同一座標を1つにまとめる |
| **基準点と同一座標の点** | ソート対象から除外する（基準点は1つだけ使う） |

同一直線上の点を凸包の辺上に含めるかどうかは仕様次第です。含める場合は、`ccw <= 0` の条件やソートの tie-break を調整する必要があります。

---

## 4.7 正しさの証明（極角ソートが正しい理由）

### なぜ極角ソートで凸包が求まるか

1. **基準点は凸包の頂点**  
   y 座標が最小の点は、凸包の下端にあり、必ず凸包の頂点です。

2. **極角ソートで反時計回りの順序になる**  
   基準点を中心に、全点を反時計回りの順に並べています。凸包を反時計回りに一周するときの頂点の順序は、この極角順の部分列になります。

3. **スタックが凸包の頂点のみを残す**  
   - 左折する限り、現在の頂点列は凸包の外側を正しくたどっています。
   - 右折が生じると、その頂点は凸包の内側にはみ出しており、凸包の頂点ではないので pop します。
   - この「左折のみ許す」ルールにより、スタックに残るのは凸包の頂点だけになります。

### なぜ同一直線上では近い点を先に並べるか

基準点 $O$ と 2 点 $A$, $B$ が同一直線上にあり、$A$ の方が $O$ に近いとします。凸包の辺としては、$O$ と $B$ を結ぶ辺だけが必要で、$A$ は辺上の中間点です。

- ソートを「近い順」にすると、処理順は $O \to A \to B$ のようになります。
- $A$ を追加するとき、$O$–$A$–$B$ は同一直線上なので `ccw <= 0` となり、$A$ が pop されます。
- その結果、スタックには $O$ と $B$ だけが残り、正しい凸包になります。

逆に「遠い順」に並べると、$B$ の処理の時点で $A$ がまだスタックに残っておらず、凸包の構造を正しく反映できなくなります。したがって、同一直線上では**近い点を先に**ソートする必要があります。

---

## 本章のまとめ

- **Graham Scan** は極角ソートとスタックで凸包を $O(n \log n)$ で求める。
- **基準点**は通常 y 最小（同点なら x 最小）の点とする。
- **極角ソート**では atan2 を用いる。同一直線上では距離が近い点を先に並べる。
- **スタック**では右折したら pop、左折するまで待ってから push する。
- 退化ケース（共線、重複、少ない点数）を適切に処理することが重要。

次章では、atan2 を使わずに座標比較だけでソートする **Andrew's Monotone Chain** を学び、数値的に安定した実装を得ます。
