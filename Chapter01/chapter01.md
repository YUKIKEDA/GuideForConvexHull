# 第1章 導入と準備

この章では、凸包を学ぶための土台を築きます。凸包とは何か、なぜ重要なのか、そして学習を始める前に必要な準備について解説します。

---

## 1.1 凸包とは何か

### 直感的な定義：釘と輪ゴムの比喩

凸包（convex hull）を理解する最も簡単な方法は、**釘と輪ゴム**の比喩です。

1. **釘を板に打つ**：平面上に複数の釘を打ちます。各釘の位置が「点」です。
2. **輪ゴムをかける**：釘全体を囲むように輪ゴムをぐるっとかけ、ぴんと張ります。
3. **凸包が現れる**：輪ゴムが釘にひっかかって形作る多角形が、その点集合の**凸包**です。

輪ゴムは常に「外側に膨らんだ」形になります。へこんだ部分は、輪ゴムが釘にひっかからないため存在しません。この「へこみのない」性質が凸包の本質です。

> ※ 釘と輪ゴムのイメージ図は、後述の可視化セクションで自分で描けるようになります。

### 数学的定義：凸集合と凸包

より厳密に定義するため、まず**凸集合**の概念を導入します。

**定義（凸集合）**

集合 $S \subseteq \mathbb{R}^d$ が**凸**であるとは、$S$ 内の任意の2点 $p, q$ について、それらを結ぶ線分全体が $S$ に含まれるときを言います。

$$
\forall p, q \in S, \forall t \in [0, 1] \colon \quad (1-t)p + tq \in S
$$

つまり、凸集合には「へこみ」がありません。任意の2点の間を直線で結んでも、常に集合の内側に留まります。

**定義（凸包）**

点集合 $P = \{p_1, p_2, \ldots, p_n\}$ の**凸包** $\mathrm{CH}(P)$ とは、$P$ のすべての点を**含む**最小の凸集合のことです。

- $P \subseteq \mathrm{CH}(P)$
- $\mathrm{CH}(P)$ は凸である
- $P$ を含む任意の凸集合 $C$ に対して、$\mathrm{CH}(P) \subseteq C$

言い換えれば、凸包は $P$ の点を「包み込む」最小の凸図形です。

### 凸包の性質と特徴

2次元の場合、凸包は次のような形で表現できます。

| 性質 | 説明 |
|------|------|
| **凸多角形** | 凸包の境界は凸多角形をなす（$n$ 点なら最大 $n$ 頂点） |
| **極点** | 凸包の頂点は、$P$ の点のうち凸包上に「飛び出している」点である |
| **一意性** | 与えられた点集合に対する凸包は一意に定まる |
| **包含関係** | 凸包の内部または境界上の点は、すべて元の点集合の凸包に属する |

3次元では凸包は**凸多面体**になり、面・辺・頂点で構成されます。高次元では**凸多面体（ポリトープ）**として一般化されます。

---

## 1.2 なぜ凸包を学ぶのか

凸包は計算幾何の基本であり、多くの分野で応用されています。

### 衝突検出（Collision Detection）

ゲームやシミュレーションでは、オブジェクト同士が重なっているかを判定する必要があります。オブジェクトの形状を凸包で近似すると、凸多面体同士の衝突判定という比較的簡単な問題に帰着できます。凸包は「外枠」として使えるため、まず凸包で粗い判定を行い、必要なら詳細な形状で再判定する、といった高速化が可能です。

### パターン認識（Pattern Recognition）

画像や点群データから物体の輪郭を抽出する際、凸包が使われます。例えば、手書き文字の特徴量として凸包の形状を用いたり、点群の「広がり」を凸包の面積や体積で測ったりします。

### 地理情報システム（GIS）

地図上に複数の地点があるとき、それらを囲む最小の凸領域を求めることは、配送ルートの計画や、観測所のカバー範囲の把握などに役立ちます。また、凸包は「この範囲内にすべての対象が含まれる」という情報を簡潔に表します。

### ロボティクス

ロボットの動作計画では、障害物や作業領域を凸多面体で表現することがあります。凸包を計算することで、ロボットや対象物の占有空間を近似し、経路計画や把持計画のアルゴリズムに利用できます。

### その他の応用

- **最適化**：凸計画問題では、実行可能領域が凸集合であることを利用する
- **データ可視化**：点群の分布を凸包で囲んで表示する
- **メッシュ生成**：Delaunay 三角分割や Voronoi 図は凸包と深い関係がある（第17章で扱う）

---

## 1.3 前提知識の確認

凸包のアルゴリズムを理解・実装するには、以下の基礎知識が必要です。自信のない項目は、この章で簡単に復習しましょう。

### 座標幾何の基礎（2D/3D）

- **2次元**：点は $(x, y)$ の組で表す。直線は $ax + by + c = 0$ や、2点を通る式で表せる。
- **3次元**：点は $(x, y, z)$ の組。平面は $ax + by + cz + d = 0$ で表せる。
- **距離**：2点 $p = (p_x, p_y)$, $q = (q_x, q_y)$ のユークリッド距離は
  $$
  d(p, q) = \sqrt{(q_x - p_x)^2 + (q_y - p_y)^2}
  $$

### ベクトルの内積・外積（Cross Product）

2次元のベクトル $\vec{a} = (a_x, a_y)$, $\vec{b} = (b_x, b_y)$ について：

**内積（スカラー）**
$$
\vec{a} \cdot \vec{b} = a_x b_x + a_y b_y
$$

**外積（2次元ではスカラー、符号付き）**
$$
\vec{a} \times \vec{b} = a_x b_y - a_y b_x
$$

外積の符号は、$\vec{a}$ から $\vec{b}$ へ反時計回りに回ると正、時計回りだと負になります。この性質は、3点の「左折・右折」判定に直結し、凸包アルゴリズムで頻繁に使います。

3次元では外積はベクトルになり、$\vec{a} \times \vec{b}$ は両者に垂直なベクトルです。

### 三角関数の基礎

極角ソート（Graham Scan など）では $\mathrm{atan2}(y, x)$ を使って、点の角度を計算します。$\mathrm{atan2}$ は $-π$ から $π$ の範囲で角度を返す関数で、象限を正しく扱えます。

### 計算量の考え方（O記法、$\log n$ の意味）

アルゴリズムの効率を表すために **O記法（ビッグオー）** を使います。

| 記法 | 意味 | 例 |
|------|------|-----|
| $O(n)$ | 入力サイズ $n$ に比例 | 線形走査 |
| $O(n \log n)$ | $n$ と $n \log n$ のオーダー | 比較ソートの最良 |
| $O(n^2)$ | $n$ の2乗に比例 | 二重ループ |
| $O(nh)$ | $n$ と凸包頂点数 $h$ の積 | Gift Wrapping |

$\log n$ は、$n$ を半分ずつに分割する操作を繰り返す回数（二分探索のステップ数など）に対応します。$n$ が大きくなっても $\log n$ はゆっくりしか増えないため、$O(n \log n)$ は実用上非常に効率的です。

---

## 1.4 開発環境のセットアップと可視化

### 言語選定（Python / C++ など）

**Python** がおすすめです。

- 文法がシンプルで、アルゴリズムの理解に集中できる
- `matplotlib` による可視化が容易
- `numpy` で数値計算ができる
- プロトタイプを早く書ける

**C++** は、速度が重要な場合や Qhull のソースを読む場合に有用です。

### 可視化ツールの準備（matplotlib / OpenGL）

**2次元**：Python なら `matplotlib` で十分です。

```bash
pip install matplotlib numpy
```

**3次元**：`matplotlib` の 3D プロット、または `PyVista` / `Open3D` などが使えます。インタラクティブな回転表示には `Plotly` も便利です。

```bash
pip install matplotlib numpy  # 2D, 簡単な3D
pip install plotly           # インタラクティブ3D（任意）
```

### 可視化のベストプラクティス

学習効率を上げるため、以下の可視化を積極的に使いましょう。

#### ステップごとの凸包構築アニメーション

Graham Scan や Gift Wrapping では、アルゴリズムが1ステップ進むごとに「現在の凸包候補」を描画します。どの点が追加され、どの点が除外されるかを目で追うことで、アルゴリズムの動きが直感的に理解できます。

#### QuickHull の再帰分割の可視化

QuickHull は直線（または平面）で点を分割しながら再帰的に凸包を構築します。各再帰段階で「どの直線で分割したか」「どちらの側の点を処理しているか」を色分けして表示すると、分割統治の構造が掴みやすくなります。

#### 3D 凸包の回転表示

3次元凸包は見る角度によって形が分かりづらいため、マウスで回転できるビューアを使うと理解が深まります。各面に色を付けると、面の枚数や隣接関係も確認しやすくなります。

#### エッジの visible / invisible 判定の可視化

増分構築法では、新たに追加した点から「見える面」「見えない面」を判定します。見える面を赤、見えない面を青などで色分けして表示すると、幾何的な意味が明確になります。

---

## 1.5 基本的なデータ構造

アルゴリズムを実装する前に、点・辺・面をどう表現するかを決めておく必要があります。

### 点の表現方法（構造体/クラス設計）

**Python** の例：

```python
from dataclasses import dataclass
from typing import List

@dataclass
class Point2D:
    x: float
    y: float

    def __sub__(self, other: "Point2D") -> "Point2D":
        return Point2D(self.x - other.x, self.y - other.y)
```

**C++** の例：

```cpp
struct Point2D {
    double x, y;
    Point2D(double x_ = 0, double y_ = 0) : x(x_), y(y_) {}
};
```

減算（差分ベクトル）や等価比較を定義しておくと、後続のコードが簡潔になります。必要に応じて、3次元用の `Point3D` も同様に定義します。

### 辺・面の表現（half-edge 構造の予告）

**2次元**では、凸包は頂点の列（反時計回りまたは時計回り）として表現するのが一般的です。隣接する2頂点のペアが「辺」になります。

**3次元**では、面・辺・頂点の関係が複雑になります。効率的に隣接関係を扱うため、**Half-edge データ構造**や **DCEL（Doubly Connected Edge List）** が使われます。これらは第15章で詳しく扱います。現段階では、「辺は2つの頂点で定義され、面は複数の辺で囲まれる」というイメージを持っておけば十分です。

### 配列 vs リンクリスト vs スタック

| データ構造 | 用途 | 凸包での利用例 |
|------------|------|----------------|
| **配列（リスト）** | 点集合の保持、ソート済み点列 | 入力点の格納、Graham Scan のソート結果 |
| **スタック** | 後入れ先出しの走査 | Graham Scan で凸包候補を管理 |
| **リンクリスト** | 挿入・削除が頻繁な列 | 動的凸包（第6章）の辺リスト |

多くの凸包アルゴリズムでは、まず点を配列に格納し、ソートやスタックを用いて凸包を構築します。実装を始める際は、配列とスタックがあれば十分です。

---

## 本章のまとめ

- **凸包**は、点集合を包む最小の凸集合であり、「釘と輪ゴム」の比喩で直感的に理解できる。
- 凸包は衝突検出、パターン認識、GIS、ロボティクスなど、幅広い分野で応用される。
- 学習には、座標幾何、ベクトル（特に外積）、三角関数、計算量の基礎知識が必要である。
- 開発には Python + matplotlib が扱いやすく、ステップ可視化や 3D 回転表示で理解を深められる。
- 点は構造体/クラスで、凸包は頂点列やスタックで表現する。3次元では Half-edge / DCEL を後で学ぶ。

次の第2章では、凸包アルゴリズムの核となる「3点の向き判定」や「凸包の性質」を詳しく扱います。
