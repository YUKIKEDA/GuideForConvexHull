# 第9章 数値的ロバストネスと性能

凸包アルゴリズムは理論上は正しくても、**浮動小数点演算**や**数値誤差**により、実装が不安定になることがあります。この章では、数値的に堅牢な実装のための落とし穴と対策、さらに性能計測の考え方を扱います。

---

## 9.1 浮動小数点の落とし穴

### 比較の誤差、eps の決め方

浮動小数点では、数学的には等しい値が一致しないことがあります。

```python
# 危険な例
a = 0.1 + 0.2  # 0.30000000000000004 になり得る
if a == 0.3:   # False になることがある
    ...
```

**eps（イプシロン）による比較**

小さな閾値 $\varepsilon$ を使い、「十分近い」ことを「等しい」とみなします。

```python
EPS = 1e-9

def eq(a: float, b: float) -> bool:
    return abs(a - b) < EPS

def cross(o, a, b) -> float:
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x)

def ccw(o, a, b) -> int:
    c = cross(o, a, b)
    if c > EPS:
        return 1
    if c < -EPS:
        return -1
    return 0
```

**eps の決め方**

| 方針 | 式 | 備考 |
|------|-----|------|
| 絶対誤差 | `abs(a - b) < 1e-9` | 座標のスケールに依存 |
| 相対誤差 | `abs(a - b) < max(abs(a), abs(b)) * 1e-9` | スケールに強い |
| スケール付き | `eps = 座標の範囲 * 1e-12` | 入力に応じて設定 |

- 競技プログラミングでは $10^{-9}$ がよく使われますが、座標が $10^{18}$ 程度だと不足することがあります。
- 座標が $10^{-6}$ 程度だと、$10^{-9}$ では厳しすぎる場合があります。
- 実用では、入力の桁数や許容誤差に合わせて調整します。

**eps の落とし穴**

- **大きすぎる**：本来は左折・右折が区別できるのに、同一直線上と誤判定する
- **小さすぎる**：誤差で正負が反転し、向き判定が逆になる

---

## 9.2 幾何計算における一般的な落とし穴（Geometric Pitfalls）

### 浮動小数点の丸め誤差による「向き判定の反転」

3点 $O$, $A$, $B$ が「ほぼ同一直線上」のとき、外積 $\text{cross}(O, A, B)$ は真の値が 0 に近く、計算誤差で正負が反転することがあります。

**問題**：本来は左折なのに右折と判定されたり、その逆になったりする。その結果、凸包の頂点の選び方が狂い、不正な凸包や無限ループが生じます。

**対策**

1. **eps による 0 判定**：`|cross| < eps` のときは「同一直線上」とし、距離などで tie-break する。
2. **高精度演算**：有理数や任意精度浮動小数点（`decimal`, `mpmath` など）で重要な判定だけ行う。
3. **記号摂動**：後述の記号摂動で退化ケースを排除する。

### ほぼ共線点の扱い

「ほぼ一直線上」の点列では、以下の問題が起きやすいです。

- **Graham Scan**：極角がほぼ同じでソート順が不安定になる
- **QuickHull**：最遠点の選択や三角形の内外判定が不安定になる
- **Gift Wrapping**：同一直線上での「より遠い点」の選択がずれる

**対策**

- Andrew's Monotone Chain のように atan2 を避け、座標比較のみでソートする
- 同一直線上では距離で比較し、近い点を先にソートする（Graham Scan）
- 許容できるなら、共線点を事前に削除する（凸包の辺上のみ残す設計にする）

### 座標が巨大な場合のオーバーフロー

外積の式

$$
(a_x - o_x)(b_y - o_y) - (a_y - o_y)(b_x - o_x)
$$

では、座標が大きいと乗算結果がオーバーフローすることがあります。例えば 32 ビット整数で $10^9$ 同士を掛けると $10^{18}$ となり、64 ビット整数の範囲内です。$10^{10}$ 同士だと $10^{20}$ で 64 ビットを超えます。

**対策**

- **整数座標**：`long long`（64 ビット）や 128 ビット整数を使う
- **浮動小数点**：`double` は約 15 桁の精度。座標が $10^{15}$ を超えると精度が落ちる
- **有理数演算**：分数で正確に計算する（速度は犠牲になる）

### 整数座標 vs 浮動小数点座標の違い

| 項目 | 整数座標 | 浮動小数点座標 |
|------|----------|----------------|
| **精度** | 正確 | 誤差あり |
| **外積** | 整数で正確に計算可能 | 丸め誤差が発生 |
| **比較** | `==` で直接比較可能 | eps が必要 |
| **範囲** | 桁数制限（オーバーフロー注意） | 指数部で広い範囲を扱える |

整数座標なら、外積も整数で計算でき、同じ直線上かどうかは `cross == 0` で正確に判定できます。凸包の問題で座標が整数に限定できるなら、`int` や `long long` で実装するのが堅牢です。

---

## 9.3 有理数・任意精度演算

厳密な結果が必要な場合は、有理数や任意精度の演算を使います。

### Python の例

```python
from fractions import Fraction

def cross_rational(o, a, b):
    """有理数で外積を計算（正確）"""
    ax = Fraction(a.x) - Fraction(o.x)
    ay = Fraction(a.y) - Fraction(o.y)
    bx = Fraction(b.x) - Fraction(o.x)
    by = Fraction(b.y) - Fraction(o.y)
    return ax * by - ay * bx

def ccw_rational(o, a, b) -> int:
    c = cross_rational(o, a, b)
    if c > 0: return 1
    if c < 0: return -1
    return 0
```

`Fraction` は既約分数として値を保持するため、加減乗除は正確です。ただし、計算量とメモリは増えます。

### 任意精度浮動小数点（mpmath）

```bash
pip install mpmath
```

```python
from mpmath import mp
mp.dps = 50  # 50 桁の精度

def cross_mp(o, a, b):
    ax = mp.mpf(a.x) - mp.mpf(o.x)
    ay = mp.mpf(a.y) - mp.mpf(o.y)
    bx = mp.mpf(b.x) - mp.mpf(o.x)
    by = mp.mpf(b.y) - mp.mpf(o.y)
    return ax * by - ay * bx
```

入力が浮動小数点のままでも、演算を任意精度で行うことで誤差を抑えられます。

---

## 9.4 記号摂動（Symbolic Perturbation）

**記号摂動**は、退化ケース（共線、同一座標など）を「摂動」によって理論的に排除する手法です。点の座標に微小な摂動を加えることで、どの3点も同一直線上に乗らないようにします。摂動は記号的（シンボリック）に扱うため、実際の座標を変更せずに、比較関数だけを摂動を考慮した形に変えます。

### アイデア

点 $p_i = (x_i, y_i)$ に摂動 $(ε^i, ε^{2i})$ を加えたと仮定します。$ε$ は無限小とみなし、$ε$ の次数で大小を決めます。このとき、異なる点は必ず異なる「摂動後の座標」を持ち、共線も生じません。

### 実装の難しさ

記号摂動の正確な実装は複雑で、多倍長整数や多項式の比較が必要になることがあります。実用では、次のような簡易版が使われることがあります。

- **ランダム摂動**：入力点に微小な乱数を加える。確率的に退化を避けるが、理論的な保証はない。
- **辞書順の tie-break**：同じ座標の点があれば、インデックスで一意に順序を決める。

厳密な記号摂動は CGAL などのライブラリで利用できます。

---

## 9.5 実用上のベストプラクティス

1. **整数で済むなら整数を使う**：外積が正確になり、比較も単純になる
2. **Andrew's Monotone Chain を優先する**：atan2 を避けられるため、数値的に安定しやすい
3. **eps は問題ごとに調整する**：入力のスケールと許容誤差に合わせる
4. **退化ケースをテストする**：共線、重複、3点以下などで挙動を確認する
5. **正解と比較する**：Qhull や既知の正解データと結果を突き合わせる

---

## 9.6 性能計測とプロファイリング

### ベンチマーク設計

**計測する指標**

- **実行時間**：wall-clock 時間または CPU 時間
- **入力サイズ**：点数 $n$
- **凸包の頂点数** $h$：出力敏感なアルゴリズムの評価に必要

**Python の例**

```python
import time
import random

def benchmark(algorithm, n, trials=5):
    times = []
    for _ in range(trials):
        points = [Point2D(random.random(), random.random()) for _ in range(n)]
        start = time.perf_counter()
        algorithm(points)
        times.append(time.perf_counter() - start)
    return sum(times) / len(times)
```

**入力パターン**

- 一様乱数（矩形内）
- 円周上（$h = n$ の最悪に近いケース）
- 格子状
- 正規分布

### ボトルネック分析

**プロファイラーを使う**

```bash
# Python
python -m cProfile -s cumulative script.py

# または line_profiler
pip install line_profiler
kernprof -l -v script.py
```

凸包アルゴリズムでは、次の部分がボトルネックになりやすいです。

- **ソート**：$O(n \log n)$ のコスト
- **外積・ccw の計算**：ループ内で頻繁に呼ばれる
- **メモリアクセス**：キャッシュの効き具合

### キャッシュ効率の考慮

- **局所性**：近くの点を連続して処理するとキャッシュヒット率が上がる
- **データレイアウト**：`Point2D` を `(x, y)` の配列にすると、x と y が別キャッシュラインに分かれる場合がある。SoA（Structure of Arrays）と AoS（Array of Structures）の使い分けを検討する
- **プリフェッチ**：大きな配列を順に走査するとき、コンパイラの最適化に任せるか、明示的なプリフェッチを検討する

**簡易的な改善例**

```python
# ソート済みの点を連続メモリで保持
points = sorted(points, key=lambda p: (p.x, p.y))
# その後、インデックスでアクセスするとキャッシュに乗りやすい
```

---

## 本章のまとめ

- **浮動小数点**では eps による比較が基本。eps の大きさは入力のスケールに依存する。
- **幾何計算の落とし穴**：向き判定の反転、ほぼ共線点、オーバーフロー、整数と浮動小数点の違いに注意する。
- **厳密な計算**が必要なら、有理数や任意精度演算、記号摂動を検討する。
- **ベンチマーク**は、入力パターンと $n$, $h$ を変えて計測する。プロファイラーでボトルネックを特定し、キャッシュ効率も考慮する。

次章では、**退化ケースとエッジケースの網羅**、**テスト駆動開発**を扱います。
